document.getElementById('app').innerHTML = 'YZ.social!'; 

/*
This is a simulation of the YZ network. 
Most people are stuck on the x/y plane. We see issues and solve them by working around them without being able 
to see within them. This is often referred to the "pink" plane.
If we are able to explore the y/z plane, we get a totally new viewpoint on the issues, reaching better understanding and power.
This is of course, the "blue" plane.
X has one dimension. Without Y and Z, it can go nowhere.

All Communication MUST BE SENT AS A MESSAGE BETWEEN NODES!
There is never direct access between nodes. It simply is not possible.

Message Types:
RequestConnection - Request a connection from a node
ApproveConnection - Approve a connection request from a node, the return message will contain the address of the 
                    node to connect to, a shared secret generated by the node, and a list of other nodes that this
                    node can also connect to.
InsertConnection - Insert a new connection into the mesh
UpdateConnection - Update an existing connection address 
*/

// Simulation
// Construct a structured node mesh

// max live connections that a node can have
const maxConnections = 10;

// all of the nodes in the global mesh
const nodeMesh = []; 

// Get random node from the nodeMesh population
const getRandomNode = () => {
    const randomIndex = Math.floor(Math.random() * nodeMesh.length);
    return nodeMesh[randomIndex];
}

// Get a random ID from the node population
const getRandomID = () => {
    const node = getRandomNode();
    return node.ID;
}

new Node(); // create the first node

for(let i = 0; i < 100; i++) {  
    // create a new node and connect it to a random node in the mesh
    const node = new Node(getRandomNode());
    console.log(node.ID);
}

// A node has a unique ID, a public key, a private key, and a list of connections
// The ID is the same as the public key
// initConnections is an array of node connections to connect to
// initConnections[0] is the "sponsor" node that the new node will initiate connection with
class Node {
    constructor( initConnections = undefined) {
        nodeMesh.push(this);  // for testing purposes...lol
        this.generateKeys();
        this.address = this; // this would normally be a public IP address
        this.next = []; // next node connections in the mesh
        this.previous = []; // previous node conections in the mesh
        this.connections = [];
        if (initConnections)
            this.requestConnection(initConnections);
    }

    // this is also the public key for the node
    get ID() {
        return this.publicKey;
    }

    get sharedSecret() { return this.generateSecret(); }
    // Calculate distance between two node IDs
    static getDistance(id1, id2) {
        // Convert both IDs to their binary representation
        const bin1 = Buffer.from(id1).toString('binary');
        const bin2 = Buffer.from(id2).toString('binary');
        
        // XOR the binary strings and count the 1s
        let distance = 0;
        const maxLength = Math.max(bin1.length, bin2.length);
        
        for (let i = 0; i < maxLength; i++) {
            const byte1 = bin1.charCodeAt(i) || 0;
            const byte2 = bin2.charCodeAt(i) || 0;
            const xor = byte1 ^ byte2;
            // Count the 1s in xor (Hamming weight)
            distance += xor.toString(2).replace(/0/g, '').length;
        }
        
        return distance;
    }

    // Get distance to another node
    distanceTo(otherNode) {
        return Node.getDistance(this.ID, otherNode.ID);
    }

    generateConnection(node) {
        return new Connection(node);
    }

    // this is a unique ID for the node
    // it will be the public key for the public/private crypto key pair
    generateKeys() {
        this.publicKey = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        this.privateKey = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    }

    generateSecret() {
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    }

    // sort the connections whenever we add a new connection so we can easily find the closest connection
    sortConnections() {
        this.connections.sort((a, b) => {
            return Node.getDistance(a.ID, b.ID);
        });
    }

    // sort the connections by date whenever we add a new connection so we can easily find the oldest connection
    sortDates() {
        this.connections.sort((a, b) => {
            // Sort by oldest first (smaller timestamps first)
            return a.lastAccessed.getTime() - b.lastAccessed.getTime();
        });
    }

    // find the closest node connection to the target node
    findClosestNode(targetNode) {
        if (this.connections.length === 0) return null;
        
        return this.connections.reduce((closest, current) => {
            const currentDistance = Node.getDistance(current.ID, targetNode.id);
            const closestDistance = Node.getDistance(closest.ID, targetNode.id);
            
            return currentDistance < closestDistance ? current : closest;
        }, this.connections[0]);
    }

    confirmConnection(connection) {
        this.connections.push(connection);
        this.sendMessage(connection, "approveConnection", {
            address: this.address,
            sharedSecret: this.generateSecret(),
            nodes: this.connections.map(conn => conn.ID);
        });
    }

    // request connection from a list of connections
    requestConnection(connections) {
        connections.forEach(connection => {
            this.sendMessage(connection, "requestConnection");
        });
    } 

    addConnection(toNode) {
        this.connections.push(new Connection(toNode));
        if (this.connections.length > maxConnections) {
            this.sortDates();
            this.connections = this.connections.slice(-maxConnections);
        }
        this.sortConnections(); // Sort after adding new connection
    }

    sendMessage(toConnection, messageType, message) {

    }

    receiveMessage(fromConnection, messageType, message) {

    }
}

class Connection {
    constructor(toConnection) {
        this.address = toConnection.address;
        this.ID = toConnection.ID;
        this._sharedSecret = toConnection.sharedSecret;
        this.lastAccessed = new Date();
    }

    get publicKey() { return this.ID; }

    get sharedSecret() { return this._sharedSecret; }

    // Add clone method
    clone() {
        const cloned = new Connection(this);
        this.secret = undefined;
        return cloned;
    }
}
