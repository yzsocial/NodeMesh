document.getElementById('app').innerHTML = 'YZ.social!'; 

/*
This is a simulation of the YZ network. 
Most people are stuck on the x/y plane. We see issues and solve them by working around them without being able 
to see within them. This is often referred to the "pink" plane.
If we are able to explore the y/z plane, we get a totally new viewpoint on the issues, reaching better understanding and power.
This is of course, the "blue" plane.
X has one dimension. Without Y and Z, it can go nowhere.

All Communication MUST BE SENT AS A MESSAGE BETWEEN NODES!
There is never direct access between nodes. It simply is not possible.

chain - a chain is a list of nodes that are connected to each other.
[previous]<->[node]<->[next]
nodeDistance
All nodes have a "distance" from each other. This is a measure of how far apart the nodes are, defined 
as converting the node IDs to a number and subtracting. This can be a positive or negative number.

Message Types:
RequestEdge - Request an edge connection from a node
ApprovedEdge - Approve an edge connection request from a node, the return message will contain the address of the 
                    node to connect to, a shared secret generated by the node, and a list of other nodes that this
                    node can also connect to.
InsertEdge - Insert a new edge connection into the mesh
UpdateEdge - Update an existing edge connection address 

proxy - every message can be forwarded via a chain of nodes until it reaches the destination node. 
This can be done by providing a chain of edge connections such that the next step is encrypted with the public
key of the next node in the chain. 

This should be written in a variant of E.
*/

//-----------------------------------------------------------------------
// A node has a unique ID, a public key, a private key, and a list of edge connections
// The ID is the same as the public key
// initEdge is the "sponsor" node that the new node will initiate an edgeconnection with
//-----------------------------------------------------------------------

const BIGINT = false;
// all of the nodes in the global mesh
const nodeMesh = []; 
const nodeMeshx = {nodes: []};
console.log("nodeMesh", nodeMesh);
console.log("nodeMeshx", nodeMeshx);
const sendMessageData = {
    closest: [],
    fromEdge: [],
    toEdge: [],
    messageType: [],
    message: [],
};
console.log("sendMessageData", sendMessageData);

// max live edges that a node can have
const MAX_EDGES = 100;
let messageCount = 0;
let messageJumpCount = 0;
let showFlag = false;
// Add these SHA-1 utility functions at the top of the file
async function generateSHA1Hash(input) {
  // Create hash from input using SubtleCrypto API
  const msgBuffer = new TextEncoder().encode(input);
  const hashBuffer = await crypto.subtle.digest('SHA-1', msgBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

// Synchronous SHA-1 alternative for when we need immediate results
function generateSHA1HashSync(input) {
  // Simple hash algorithm (not cryptographically secure, but deterministic)
  let hash = 0;
  for (let i = 0; i < input.length; i++) {
    const char = input.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  
  // Convert to hex string with padding to look like SHA-1
  let hexString = Math.abs(hash).toString(16);
  return hexString.padStart(40, '0');
}

class Node {
    constructor(initNode = undefined, index) {
        nodeMesh.push(this);
        nodeMeshx.nodes.push(this);
        nodeMeshx.nodes = nodeMeshx.nodes.slice(-10);
        this.generateKeys();
        if(index) this.publicKey = index;
        this.address = this;
        this.next = [];
        this.previous = [];
        this.edges = [];
        this.lastAccessed = new Date();

        // Initialize network properties
        this.publicIP = null;
        this.publicPort = null;
        this.natType = null;
        this.privateIP = null;
        this.privatePort = null;
        
        if (initNode) {
            this.connectTo(initNode);
            const sharedSecret = this.findEdge(initNode.ID).sharedSecret;
            // console.log("sharedSecret", sharedSecret);
            this.sendMessage(new Edge(this), new Edge(initNode), "joinMesh", this.encryptMessage(sharedSecret, initNode.publicKey));
        }
    }

    encryptMessage(message, key) { return message;}
    decryptMessage(message, key) { return message;}

    connectTo(newEdge) {
        // Make sure we're creating an edge connection with an Edge object 
        // NOTE: when we first touch another node (QR or otherwise) we exchange our edges + our shared secrets
        // Thus, the construction of this edge will not look like this
        const yourEdge = new Edge(newEdge);
        const myEdge = new Edge(this);
        yourEdge.sharedSecret = this.generateSecret(newEdge.ID);
        myEdge.sharedSecret = yourEdge.sharedSecret;
        // console.log("sharedSecret", yourEdge.sharedSecret, myEdge.sharedSecret);
        newEdge.edges.unshift(myEdge);
        this.edges.unshift(yourEdge);
        // this.sendMessage(myEdge, yourEdge, "requestEdge", myEdge.sharedSecret); // sharedSecret will be encrypted by the public key of the newEdge
    }

    // this is also the public key for the node
    get ID() { return this.publicKey; }
    
    // Calculate distance between two node IDs
    static getDistance(id1, id2) {
        if(BIGINT) return BigInt('0x'+id2) - BigInt('0x'+id1);
        else return id2-id1;
    }

    static getOrder(id1, id2) {
        if( id1 > id2 ) return -1; // id2 is before id1
        if( id1 < id2 ) return 1; // id2 is after id1
        return 0; // they are the same
    }

    // Get distance to another node
    distanceTo(otherNode) {
        return Node.getDistance(this.ID, otherNode.ID);
    }

    // this is a unique ID for the node
    // it will be the public key for the public/private crypto key pair
    generateKeys() {
        if(BIGINT) {
            // Generate a unique random string
            const randomValue = Math.random().toString() + Date.now().toString();
        
            // Generate privateKey as a SHA-1 hash
            this.privateKey = generateSHA1HashSync(randomValue);
            
            // Generate publicKey as SHA-1 hash of privateKey
            // This creates a relationship between private and public keys
            this.publicKey = generateSHA1HashSync(this.privateKey);
            
            return this.publicKey;
        } else {
            this.privateKey = Math.random();
            this.publicKey = Math.random();
            return this.publicKey;
        }
    }

    // this is a unique shared secret between two connected nodes
    generateSecret(key) {
        // Generate a unique random value for the secret
        const randomValue = Math.random().toString() + Date.now().toString() + key;
        
        // Use SHA-1 hash of the random value as the secret
        return generateSHA1HashSync(randomValue);
    }

    // sort the edges whenever we add a new edge so we can easily find the closest edge
    sortEdges(edges, s2l = true) {
        return edges.sort((a, b) => {
            return s2l ? Node.getOrder(a.ID, b.ID) : Node.getOrder(b.ID, a.ID); // order from smallest to largest values
        });
    }

    // sort the edges by date whenever we add a new edge so we can easily delete the oldest edges
    sortDates(edges) {
        return edges.sort((a, b) => {
            // Sort by oldest first (smaller timestamps first)
            return a.lastAccessed.getTime() - b.lastAccessed.getTime();
        });
    }


    // add the new edge and send a confirmation message back to the requesting node
    // the confirmation message will include a shared secret.
    confirmEdge(newEdge) {
    //    console.log("confirmEdge --------------------- ", toEdge.ID, this.ID);
        const myEdge = new Edge(this);
        const secret = this.generateSecret(newEdge.ID);
        myEdge.secret = secret;
        newEdge.secret = secret;
        const updated = this.updateEdge(newEdge);
        if (!updated){
            this.edges.push(newEdge.clone());
            this.edges = this.sortDates(this.edges);
            this.edges = this.edges.slice(-MAX_EDGES); 
        }
        this.sendMessage(myEdge, newEdge.clone(), "approvedEdge");
    }

    // response from a node that has approved a edge request
    approvedEdge(newEdge) {
    //    console.log("approvedEdge --------------------- ", newEdge.ID, this.ID);
        const updated = this.updateEdge(newEdge);
        if (!updated){
            this.edges.push(new Edge(newEdge));
            this.edges = this.sortDates(this.edges);
            this.edges = this.edges.slice(-MAX_EDGES); 
        }
    }

    // this is the first edge to the mesh - from new node to sponsor node
    joinMesh(newEdge, encryptedSharedSecret) {
        const sharedSecret = this.decryptMessage(encryptedSharedSecret, newEdge.ID);
        const closest = this.findEdge(newEdge.ID);
        // You can only join the mesh if the shared secret is the same 
        // console.log("joinMesh - closest found, insertEdge", closest.ID, newEdge.ID);
        if(closest && closest.ID === newEdge.ID && closest.sharedSecret && closest.sharedSecret === sharedSecret) {
            // console.log("joinMesh - sharedSecret is the same", sharedSecret, closest.sharedSecret);
            //this.sendMessage(newEdge, new Edge(this), "insertEdge");
            this.insertEdge(newEdge.clone())
        }
    }

    // insert a new edge into the mesh such that the previous node ID is less than the new edge ID
    // and the next node ID is greater than the new edge ID
    insertEdge(newEdge) { 
        // console.log("insertEdge - newEdge", this.ID, newEdge.ID);
        let rval = false;
        const order = Node.getOrder(this.ID,newEdge.ID);
        // console.log("order", this.ID, newEdge.ID, order);
        if(order < 0) { // the newEdge is a previous node to the left
            // console.log("insert to the left ", this.previous.length);
            if(this.previous.length > 0) { // there is a previous node
                let closest = this.findEdge(this.ID, "previous"); 
                // console.log("this", this.ID, "insert", newEdge.ID, "previous", closest?.ID);
                if(closest.ID < newEdge.ID){
                    this.previous.unshift(newEdge.clone()); // newEdge is new closest previous node
                    this.sendMessage(new Edge(this),newEdge.clone(), "setNextEdge"); // this is newEdge's next node
                    this.sendMessage(closest.clone(), new Edge(newEdge.clone()), "setPreviousEdge"); // closest is newEdge's previous node
                    this.sendMessage(new Edge(newEdge.clone()), closest, "setNextEdge"); // newEdge is closest next node
                    rval = true;
                 }else{
                    // someone else will insert the new edge
                    let closest = this.findEdge(newEdge.ID, "notEqual");
                    if(closest && closest != newEdge.ID) this.sendMessage(new Edge(this), closest, "insertEdge", newEdge.clone());
                    else    ("closest not found", newEdge.ID, this.ID); // this should never happen
                }
            } else { // there is no previous node, so insert the new edge at the beginning of the previous array
                // console.log("insert to the left, first previous", newEdge.ID, this.ID);
                this.previous.unshift(newEdge.clone());
                this.sendMessage(new Edge(this), newEdge.clone(), "setNextEdge");
                rval = true;
            }
        } else if (order > 0) { // the newEdge is a next node to the right
            // console.log("insert to the right ", this.next.length);
            if(this.next.length > 0) { // there is a next node
                let closest = this.findEdge(this.ID, "next"); // only check next nodes
                // console.log("this", this.ID, "insert", newEdge.ID, "next", closest?.ID);
                if(closest.ID > newEdge.ID){
                    this.next.unshift(newEdge.clone()); // newEdge is new closest previous node
                    this.sendMessage(new Edge(this),newEdge.clone(), "setPreviousEdge"); // this is newEdge's next node
                    this.sendMessage(closest.clone(), new Edge(newEdge.clone()), "setNextEdge"); // closest is newEdge's previous node
                    this.sendMessage(new Edge(newEdge.clone()), closest, "setPreviousEdge"); // newEdge is closest next node
                    rval = true;
                 }else{
                    // someone else will insert the new edge
                    let closest = this.findEdge(newEdge.ID, "notEqual");
                    if(closest && closest != newEdge.ID) this.sendMessage(new Edge(this), closest, "insertEdge", newEdge.clone());
                    else console.log("closest not found", newEdge.ID, this.ID); // this should never happen
                }
            } else { // there is no next node, so insert the new edge at the beginning of the next array
                // console.log("insert to the right, first next", this.ID,newEdge.ID);
                this.next.unshift(newEdge.clone());
                this.sendMessage(new Edge(this), newEdge, "setPreviousEdge");
                rval = true;
            }
        } else {
            console.log("insertEdge - order is 0", this.ID, newEdge.ID);
        }
        return rval;
    }


    setPreviousEdge(fromEdge) {
        //        console.log("setPreviousEdge --------------------- ", fromEdge.ID, this.ID);
        let edge = fromEdge.clone();
        this.previous.unshift(edge);
    //    this.approvedEdge(edge);
    }

    setNextEdge(fromEdge) {
//        console.log("setNextEdge --------------------- ", fromEdge.ID, this.ID);
        let edge = fromEdge.clone();
        this.next.unshift(edge);
    //    this.approvedEdge(edge);
    }   

            
    // find the closest edge to the target nodeId 
    // - search edges for the closest edge there
    // - search previous if the target nodeId is less than this nodeId
    // - search next if the target nodeId is greater than this nodeId

    findEdge(nodeId, direction = "all") {
        let bestEdge = null;
        let bestDistance = Infinity;

        // Helper function to check and update best edge
        const checkEdge = (edge) => {
            // Calculate distance to target nodeId
            if(direction !== "all" && nodeId === edge.ID) return;
            let distance = Node.getDistance(nodeId, edge.ID);
            distance = distance < 0 ? -distance : distance; // BigInt
            if (distance < bestDistance) {
                bestDistance = distance;
                bestEdge = edge;
            }
        };

        if(direction === "all" || direction === "notEqual")
            for (const edge of this.edges) {
                checkEdge(edge);
            }
 //console.log("bestEdge - edges1 ", nodeId, bestEdge?.ID, notExact);
        // Linear search through this.previous
        if(direction !== "next") for (const edge of this.previous) {
            checkEdge(edge);
        }
 //console.log("bestEdge - previous ", nodeId, bestEdge?.ID);
        // Linear search through this.next
        if(direction !== "previous") for (const edge of this.next) {
            checkEdge(edge);
        }

        return bestEdge; // there should at least be one.
    }

    sendMessage(fromEdge, toEdge, messageType, message) {
       // console.log("sendMessage ", this.ID, fromEdge.ID, toEdge.ID, messageType);
        if(fromEdge.jumpCount === 0) messageCount++;
        fromEdge.jumpCount++;
        messageJumpCount++;
        if (toEdge.ID === this.ID) { // this is me
            this.receiveMessage(fromEdge, messageType, message);
        } else {
            const closest = this.findEdge(toEdge.ID); 
            if (closest) {
                //if(showFlag) console.log("sendMessage + --------------------- ", closest.ID, this.ID, toEdge.ID);
                sendMessageData.closest.unshift(closest.ID); sendMessageData.closest = sendMessageData.closest.slice(-100);
                sendMessageData.fromEdge.unshift(fromEdge.ID); sendMessageData.fromEdge = sendMessageData.fromEdge.slice(-100);
                sendMessageData.toEdge.unshift(toEdge.ID); sendMessageData.toEdge = sendMessageData.toEdge.slice(-100);
                sendMessageData.messageType.unshift(messageType); sendMessageData.messageType = sendMessageData.messageType.slice(-100);
                sendMessageData.message.unshift(message); sendMessageData.message = sendMessageData.message.slice(-100);
                closest.address.sendMessage(fromEdge, toEdge, messageType, message); // this would be a network send
            }
            else console.error("No closest node found for ", messageType, toEdge, this);
        }
    }

    setPreviousEdge(fromEdge) {
//        console.log("setPreviousEdge --------------------- ", fromEdge.ID, this.ID);
        let edge = fromEdge.clone();
        this.previous.unshift(edge);
        this.approvedEdge(edge);
    }

    setNextEdge(fromEdge) {
//        console.log("setNextEdge --------------------- ", fromEdge.ID, this.ID);
        let edge = fromEdge.clone();
        this.next.unshift(edge);
        this.approvedEdge(edge);
    }   

    receiveMessage(fromEdge, messageType, message) {
    //    console.log("receiveMessage --------------------- ", this.ID, fromEdge.ID, this.ID, messageType);
        switch(messageType) {
            case "joinMesh":
                this.joinMesh(fromEdge, message);
                break;
            case "requestEdge":
                this.confirmEdge(fromEdge);
                break;
            case "approvedEdge":
                this.approvedEdge(fromEdge);
                break;
            case "insertEdge":
                this.insertEdge(message);
                break;
            case "setPreviousEdge":
                this.setPreviousEdge(fromEdge);
                break;
            case "setNextEdge":
                this.setNextEdge(fromEdge);
                break;
            case "message":
                this.processMessage(fromEdge, message);
                break;
            case "introducedTo":
                this.handleIntroduction(fromEdge, message);
                break;
            case "endpointInfo":
                // Now we know our public IP/port as seen by the other node
                this.publicIP = message.publicIP;
                this.publicPort = message.publicPort;
                break;
        }
    }

    // Process the received message
    processMessage(fromEdge, message) {
        // display the message - there are MANY messages, so don't uncomment unless you want to see all of them
        //   console.log("processMessage --------------------- ", this.ID, fromEdge.ID, message);
    }

    // Process each edge with a given function
    processEdges(processFn) {
        return this.edges.map(processFn);
    }
    
    // Process edges with async functions
    async processEdgesAsync(processFn) {
        return Promise.all(this.edges.map(processFn));
    }

    // Update all instances of a edge across edges, previous, and next arrays
    updateEdge(newEdge) {
        let updated = false;
        
        // Update main edges array
        this.edges = this.edges.map(conn => {
            if (conn.ID === newEdge.ID) {
                updated = true;
                return newEdge;
            }
            return conn;
        });

        // Update previous array
        this.previous = this.previous.map(conn => {
            if (conn.ID === newEdge.ID) {
                updated = true;
                return newEdge.clone();
            }
            return conn;
        });

        // Update next array
        this.next = this.next.map(conn => {
            if (conn.ID === newEdge.ID) {
                updated = true;
                return newEdge.clone();
            }
            return conn;
        });

        return updated;
    }

    // Alternative version using processEdges
    updateEdgeAlt(newEdge) {
        const updateArray = (array) => {
            return array.map(conn => 
                conn.ID === newEdge.ID ? newEdge.clone() : conn
            );
        };

        // Update all arrays
        this.edges = updateArray(this.edges);
        this.previous = updateArray(this.previous);
        this.next = updateArray(this.next);

        // Check if any updates were made
        return [...this.edges, ...this.previous, ...this.next]
            .some(conn => conn.ID === newEdge.ID);
    }

    // Introduce two nodes that are both connected to this node
    introduceNodes(node1Edge, node2Edge) {
        // First verify both edges exist
        if (!this.hasEdge(node1Edge) || !this.hasEdge(node2Edge)) {
            console.error("Can only introduce nodes that are connected to this node");
            return;
        }

        // Create introduction messages with full edge context
        const introMessage1 = {
            edge: node2Edge.getPublicInfo(),
            introducer: {
                ID: this.ID,
                edge: new Edge(this).getPublicInfo()
            }
        };

        const introMessage2 = {
            edge: node1Edge.getPublicInfo(),
            introducer: {
                ID: this.ID,
                edge: new Edge(this).getPublicInfo()
            }
        };

        // Send introductions with proper routing context
        this.sendMessage(new Edge(this), node1Edge, "introducedTo", introMessage1);
        this.sendMessage(new Edge(this), node2Edge, "introducedTo", introMessage2);
    }

    // Check if we have an active edge to this node by ID
    hasEdge(edge) {
        const targetID = edge.ID;
        return [...this.edges, ...this.previous, ...this.next]
            .some(conn => conn.ID === targetID);
    }

    // Handle being introduced to a new node
    handleIntroduction(introducerEdge, message) {
        // Get introducer's actual ID from the message
        const introducerID = message.introducer.ID;
        
        // Try to find the introducer in our edges
        let introducerFound = this.findEdge(introducerID);
        
        if (!introducerFound) {
            // If we don't have the introducer edge, establish it first
            console.log("Establishing edge to introducer first...");
            const tempEdge = new Edge({
                ...message.introducer.edge,
                address: {
                    sendMessage: () => {},
                    ...message.introducer.edge
                }
            });
            
            // Request edge to introducer first
            this.sendMessage(new Edge(this), tempEdge, "requestEdge");
            return; // Wait for edge to be established before proceeding
        }

        // Create new edge with the public information
        const newEdge = new Edge({
            ...message.edge,
            address: {
                sendMessage: () => {},
                ...message.edge
            }
        });

        // Attempt to establish edge
        this.establishP2PEdge(newEdge, {
            publicIP: introducerEdge.publicIP,
            publicPort: introducerEdge.publicPort
        });
    }

    establishP2PEdge(newEdge, introducerInfo) {
        // Different strategies based on NAT types
        switch(newEdge.natType) {
            case 'FullCone':
                // Can connect directly to the public IP/port
                this.connectDirect(newEdge);
                break;
                
            case 'RestrictedCone':
            case 'PortRestrictedCone':
                // Need hole punching, use introducer info
                this.connectWithHolePunching(newEdge, introducerInfo);
                break;
                
            case 'Symmetric':
                // Might need relay if both peers are symmetric NAT
                this.connectWithRelay(newEdge);
                break;
        }
    }

    // Attempt direct edge and get our public endpoint
    async connectDirect(targetEdge) {
        // 1. Send packet to target's public endpoint to create NAT mapping
        this.sendUDPPacket(targetEdge.publicIP, targetEdge.publicPort, {
            type: "edgeRequest",
            privateIP: this.privateIP,
            privatePort: this.privatePort,
            ID: this.ID
        });

        // 2. Target will receive packet and get our public endpoint from the packet
        // 3. Target sends back our public endpoint info
        this.sendMessage(new Edge(this), targetEdge, "requestEndpointInfo");
    }

    // Handle receiving a UDP packet
    handleUDPPacket(packet, rinfo) {
        // rinfo contains sender's public endpoint (from UDP packet headers)
        const { address: senderPublicIP, port: senderPublicPort } = rinfo;

        if (packet.type === "edgeRequest") {
            // Store sender's endpoint information
            const senderEdge = this.findEdge(packet.ID);
            if (senderEdge) {
                senderEdge.publicIP = senderPublicIP;
                senderEdge.publicPort = senderPublicPort;
                senderEdge.privateIP = packet.privateIP;
                senderEdge.privatePort = packet.privatePort;

                // Send back their public endpoint info
                this.sendMessage(new Edge(this), senderEdge, "endpointInfo", {
                    publicIP: senderPublicIP,
                    publicPort: senderPublicPort
                });
            }
        }
    }
}

//-----------------------------------------------------------------------
// Edge Class
// A edge holds information about a target node that allows another
// node to send messages to it.
//-----------------------------------------------------------------------
class Edge {
    constructor(node) {
        // Basic identification
        this.publicKey = node.publicKey;
        
        // Handle both Node instances and temporary node-like objects
        if (node.address) {
            // If it's a Edge object or has an address property
            this.address = node.address;
        } else {
            // If it's a Node instance or a temporary node-like object
            this.address = node;
        }
        
        this.lastAccessed = new Date();
        this.jumpCount = 0;

        // Real network information (get from the actual node/object)
        const sourceNode = this.address;
        this.publicIP = sourceNode.publicIP;
        this.publicPort = sourceNode.publicPort;
        this.natType = sourceNode.natType;
        this.privateIP = sourceNode.privateIP;
        this.privatePort = sourceNode.privatePort;

        // For secure communication
        // this.secret = sourceNode.secret;
    }

    get ID() { return this.publicKey; }
    // Clone method needs to copy all network info and maintain node reference
    clone() {
        this.lastAccessed = new Date();
        return new Edge(this);
    }

    // Get edge info that can be shared with other peers
    getPublicInfo() {
        return {
            ID: this.ID,
            publicIP: this.publicIP,
            publicPort: this.publicPort,
            natType: this.natType
        };
    }
}

//-----------------------------------------------------------------------
// Simulation
// Construct a structured node mesh
// The node ID/public key is a unique identifier for the node
// For simulation purposes, we will use Math.random() to generate a unique ID for each node
//-----------------------------------------------------------------------

// This is the number of nodes to create
const NODE_COUNT = 100000;


// Get random node from the nodeMesh population
const getRandomNode = () => {
    const randomIndex = Math.floor(Math.random() * nodeMesh.length);
    return nodeMesh[randomIndex]; 
}

// Get a random ID from the node population
const getRandomID = () => {
    const node = getRandomNode();
    return node.ID;
}

new Node(); // create the first node

for(let i = 0; i < NODE_COUNT; i++) {  
    // Pass the random node itself, not a edge
    const randomNode = getRandomNode();
    const node = new Node(randomNode);
    if(i % 10000 === 0) console.log("Node ", i, node.ID);
}

function reportStats() {
    let ac = 0, an = 0, ap = 0, mc = 0, mp = 0, mn = 0;
    let edgeCount = [];
    let previousCount = [];
    let nextCount = [];
    let totalEdges = 0;
    for(let i = 0; i < nodeMesh.length; i++) {
        let node = nodeMesh[i];
        if (node.edges.length > mc) mc = node.edges.length;
        totalEdges += node.edges.length;
        if (node.previous.length > mp) mp = node.previous.length;
        if (node.next.length > mn) mn = node.next.length;

        ac += node.edges.length;
        ap += node.previous.length;
        an += node.next.length;
        edgeCount[node.edges.length] = (edgeCount[node.edges.length] || 0) + 1;
        previousCount[node.previous.length] = (previousCount[node.previous.length] || 0) + 1;
        nextCount[node.next.length] = (nextCount[node.next.length] || 0) + 1;
    }
    console.log("--------------------------------");
    //console.log("Max ", "mc", mc, "mp", mp, "mn", mn);
    //console.log("Average ", "ac", ac/nodeMesh.length, "ap", ap/nodeMesh.length, "an", an/nodeMesh.length);
    console.log("Total Edges ", totalEdges);
    console.log("Edges ", edgeCount);
    console.log("Previous ", previousCount);
    console.log("Next ", nextCount);
    console.log("Average Jump Count ", messageJumpCount/(messageCount||1));
}
reportStats();

function testScale(scale) {
    showFlag = true;
    console.log("Test Scale 1");

    for(let i = 0; i < scale; i++) {
        //console.log("Request ", i);
        let fromNode = getRandomNode();
        let toNode = getRandomNode();
        if(fromNode.ID === toNode.ID) continue;//
        fromNode.connectTo(toNode);
        // fromNode.sendMessage(new Edge(fromNode), new Edge(toNode), "requestEdge", "Hello");
        if(i % 10000 === 0) console.log("Request ", i);
    }


    console.log("Test Scale 2");
//    reportStats();
    messageJumpCount = messageCount = 0;
    for(let i = 0; i < 100000; i++) {
        // console.log("Message ", i);
        let fromNode = getRandomNode();
        let toNode = getRandomNode();
        fromNode.sendMessage(new Edge(fromNode), new Edge(toNode), "message", "Hello");
    }
    reportStats();
}

// testScale(1);
for(let i = 0; i < 10; i++) testScale(100000);
// testScale(10000);
// testScale(100000);
// testScale(1000000);
// testScale(10000000);
// testScale(100000000);

// Add this utility function to your code
function capArraySize(array, maxSize, sortFn = null) {
    if (array.length <= maxSize) return array; // No need to cap if under limit
    
    // Sort the array if a sort function is provided
    if (sortFn) {
        array.sort(sortFn);
    }
    
    // Return only the last maxSize elements (newest elements)
    return array.slice(-maxSize);
}
