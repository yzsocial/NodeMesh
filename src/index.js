document.getElementById('app').innerHTML = 'YZ.social!'; 

/*
This is a simulation of the YZ network. 
Most people are stuck on the x/y plane. We see issues and solve them by working around them without being able 
to see within them. This is often referred to the "pink" plane.
If we are able to explore the y/z plane, we get a totally new viewpoint on the issues, reaching better understanding and power.
This is of course, the "blue" plane.
X has one dimension. Without Y and Z, it can go nowhere.

All Communication MUST BE SENT AS A MESSAGE BETWEEN NODES!
There is never direct access between nodes. It simply is not possible.

nodeDistance
All nodes have a "distance" from each other. This is a measure of how far apart the nodes are, defined 
as converting the node IDs to a number and subtracting. This can be a positive or negative number.

Message Types:
RequestConnection - Request a connection from a node
ApprovedConnection - Approve a connection request from a node, the return message will contain the address of the 
                    node to connect to, a shared secret generated by the node, and a list of other nodes that this
                    node can also connect to.
InsertConnection - Insert a new connection into the mesh
UpdateConnection - Update an existing connection address 


proxy - every message can be forwarded via a chain of nodes until it reaches the destination node. 
This can be done by providing a chain of connections such that the next step is encrypted with the public
key of the next node in the chain. 
*/

//-----------------------------------------------------------------------
// A node has a unique ID, a public key, a private key, and a list of connections
// The ID is the same as the public key
// initConnection is the "sponsor" node that the new node will initiate connection with
//-----------------------------------------------------------------------
class Node {
    constructor( initConnection = undefined) {
        nodeMesh.push(this);  // for testing purposes...lol
        this.generateKeys(); // generate my public/private key pair
        this.address = this; // this would normally be a public IP address - for simulation, it's just the node itself
        this.next = []; // next node connections in the mesh
        this.previous = []; // previous node conections in the mesh
        this.connections = []; // list of connections to other nodes
        if (initConnection) {
            this.connections.unshift(new Connection(initConnection));
            this.sendMessage(new Connection(this), new Connection(initConnection), "requestConnection");
        }
        console.log("--------------------------Node constructor", this.ID);
    }

    // this is also the public key for the node
    get ID() { return this.publicKey; }
    
    // Calculate distance between two node IDs
    static getDistance(id1, id2) {
        return id2 - id1;
    }

    // Get distance to another node
    distanceTo(otherNode) {
        return Node.getDistance(this.ID, otherNode.ID);
    }

    // this is a unique ID for the node
    // it will be the public key for the public/private crypto key pair
    generateKeys() {
        this.publicKey = Math.random();
        this.privateKey = Math.random();
    }

    // this is a unique shared secret between two connected nodes
    generateSecret() {
        return Math.random();
    }

    // sort the connections whenever we add a new connection so we can easily find the closest connection
    sortConnections() {
        this.connections.sort((a, b) => {
            return Node.getDistance(a.ID, b.ID);
        });
    }

    // sort the connections by date whenever we add a new connection so we can easily delete the oldest connections
    sortDates() {
        this.connections.sort((a, b) => {
            // Sort by oldest first (smaller timestamps first)
            return a.lastAccessed.getTime() - b.lastAccessed.getTime();
        });
    }

    // find the closest node connection to the target node ID using binary search
    static findClosestNode(nodeId, connections, currentNodeId) {
        if (!connections || connections.length === 0) return null;
        if (connections.length === 1) {
            // Only return the connection if it's in the correct direction
            const isGreater = Node.getDistance(currentNodeId, nodeId) > 0;
            const connectionIsGreater = Node.getDistance(currentNodeId, connections[0].ID) > 0;
            return (isGreater === connectionIsGreater) ? connections[0] : null;
        }
        
        // Determine search direction based on target node position
        const searchGreater = Node.getDistance(currentNodeId, nodeId) > 0;
        
        let left = 0;
        let right = connections.length - 1;
        
        // Binary search to find the closest position
        while (left <= right) {
            if (right - left <= 1) {
                const leftDist = Node.getDistance(currentNodeId, connections[left].ID);
                const rightDist = Node.getDistance(currentNodeId, connections[right].ID);
                
                // Only consider connections in the correct direction
                const leftValid = searchGreater ? leftDist > 0 : leftDist < 0;
                const rightValid = searchGreater ? rightDist > 0 : rightDist < 0;
                
                if (!leftValid && !rightValid) return null;
                if (!leftValid) return connections[right];
                if (!rightValid) return connections[left];
                
                // Both are valid, return the closer one
                const distLeft = Math.abs(Node.getDistance(connections[left].ID, nodeId));
                const distRight = Math.abs(Node.getDistance(connections[right].ID, nodeId));
                return distLeft <= distRight ? connections[left] : connections[right];
            }
            
            const mid = Math.floor((left + right) / 2);
            const midVal = connections[mid].ID;
            
            if (midVal === nodeId) {
                return connections[mid];
            }
            
            if (midVal < nodeId) {
                left = mid;
            } else {
                right = mid;
            }
        }
        
        // Verify the found connection is in the correct direction
        const foundDist = Node.getDistance(currentNodeId, connections[left].ID);
        const isValidDirection = searchGreater ? foundDist > 0 : foundDist < 0;
        return isValidDirection ? connections[left] : null;
    }

    // Find the closest connection from newConnections, comparing against referenceConnection
    static findClosestFromArray(nodeId, referenceConnection, newConnections) {
        if (!newConnections || newConnections.length === 0) return referenceConnection;
        
        // Start with the reference connection as our best match
        let closestConnection = referenceConnection;
        let minDistance = Math.abs(Node.getDistance(nodeId, referenceConnection.ID));
        
        // Linear search through newConnections to find any closer match
        for (const connection of newConnections) {
            const distance = Math.abs(Node.getDistance(nodeId, connection.ID));
            if (distance < minDistance) {
                minDistance = distance;
                closestConnection = connection;
            }
        }
        
        return closestConnection;
    }

    // Instance method wrapper
    findClosestFromArray(targetNode, referenceConnection, newConnections) {
        return Node.findClosestFromArray(targetNode.ID, referenceConnection, newConnections);
    }

    // Update the instance method to use the static method
    findClosestNode(targetNode) {
        if (Node.getDistance(this.ID, targetNode.ID) > 0) {
            // Target is greater than current node, search in next connections
            return Node.findClosestNode(targetNode.ID, this.next);
        } else {
            // Target is less than current node, search in previous connections
            return Node.findClosestNode(targetNode.ID, this.previous);
        }
    }

    // add the new connection and send a confirmation message back to the requesting node
    // the confirmation message will include a shared secret.
    confirmConnection(toConnection) {
        console.log("--------------------- confirmConnection", toConnection.ID, this.ID);
        const fromConnection = new Connection(this);
        const secret = this.generateSecret();
        fromConnection.secret = secret;
        toConnection.secret = secret;
        this.connections.push(toConnection);
        this.sendMessage(fromConnection, toConnection, "approvedConnection");
    }

    // response from a node that has approved a connection request
    approvedConnection(fromConnection) {
        console.log("--------------------- approvedConnection", fromConnection.ID, this.ID);
        const updated = this.updateConnection(fromConnection);
        if (!updated) this.connections.push(new Connection(fromConnection));
        if (this.connections.length > MAX_CONNECTIONS) {
            this.sortDates();
            this.connections = this.connections.slice(-MAX_CONNECTIONS);
        }
        this.sortConnections(); // Sort after adding new connection
        // check if we have been inserted into the mesh
        if(this.previous.length === 0 && this.next.length === 0) this.sendMessage(new Connection(this), null, "insertConnection");
    }

    // insert a new connection into the mesh such that the previous node ID is less than the new connection ID
    // and the next node ID is greater than the new connection ID
    insertConnection(fromConnection, direction) {
        console.log("--------------------- insertConnection", fromConnection.ID, this.ID);
        if(this.distanceTo(fromConnection) < 0) { // the fromConnection is to the left of this node
            console.log("insert to the left ", this.previous.length);
            if(this.previous.length > 0) {
                // if fromConnection is closer to this node than the previous node, insert it
                if( Node.getDistance(this.previous[0].ID, fromConnection.ID) > 0 ){
                    console.log("insert left", this.previous[0].ID, fromConnection.ID, this.ID);
                    const previous = this.previous[0];
                    this.previous.unshift(fromConnection.clone());
                    // send the new connection back to the previous node
                    previous.address.sendMessage(fromConnection, previous, "setNextConnection");
                    // send the new connection back to requesting connection
                    this.sendMessage(new Connection(this), fromConnection, "setNextConnection");
                    this.sendMessage(new Connection(previous), fromConnection, "setPreviousConnection");
                } else this.sendMessage(fromConnection, "left", "insertConnection");
            } else {
                console.log("insert to the left, first previous", fromConnection.ID, this.ID);
                this.previous.unshift(fromConnection.clone());
                this.sendMessage(new Connection(this), fromConnection, "setNextConnection");
            }
        } else if (this.distanceTo(fromConnection) > 0) {
            console.log("insert to the right ", this.next.length);
            if(this.next.length > 0) {
                if( Node.getDistance(this.next[0].ID, fromConnection.ID) < 0){
                    console.log("insert right", this.next[0].ID, fromConnection.ID, this.ID);
                    const next = this.next[0];
                    this.next.unshift(fromConnection.clone());
                    next.address.sendMessage(fromConnection, next, "setPreviousConnection");
                    // send the new connection back to requesting connection
                    this.sendMessage(new Connection(this), fromConnection, "setPreviousConnection");
                    this.sendMessage(new Connection(next), fromConnection, "setNextConnection");
                } else this.sendMessage(fromConnection, "right", "insertConnection");
            } else {
                console.log("insert to the right, first next", this.ID,fromConnection.ID);
                this.next.unshift(fromConnection.clone());
                this.sendMessage(new Connection(this), fromConnection, "setPreviousConnection");
            }
        }
    }

    sendMessage(fromConnection, toConnection, messageType, message) {
        console.log("--------------------- sendMessage", this.ID, fromConnection.ID, toConnection?.ID, messageType);
        if (messageType === "insertConnection") {
            if(this.ID !== fromConnection.ID) this.insertConnection(fromConnection, toConnection);
            else {
                const closest = this.findConnection(fromConnection.ID);
                if (closest) closest.address.sendMessage(fromConnection, null, messageType, message);
                else console.log("No closest node found for ", messageType);
            }
        }
        else if (toConnection?.ID === this.ID) { // this is me
            this.receiveMessage(fromConnection, messageType, message);
        } else {
            const closest = this.findConnection(toConnection?.ID || fromConnection.ID);
            console.log("closest", closest.ID);
            if (closest) closest.address.sendMessage(fromConnection, toConnection, messageType, message);
            else console.log("No closest node found for ", messageType);
        }
    }

    setPreviousConnection(fromConnection) {
        console.log("--------------------- setPreviousConnection", fromConnection.ID, this.ID);
        let connection = fromConnection.clone();
        this.previous.unshift(connection);
        this.approvedConnection(connection);
    }

    setNextConnection(fromConnection) {
        console.log("--------------------- setNextConnection", fromConnection.ID, this.ID);
        let connection = fromConnection.clone();
        this.next.unshift(connection);
        this.approvedConnection(connection);
    }   

    receiveMessage(fromConnection, messageType, message) {
        console.log("--------------------- receiveMessage", this.ID, fromConnection.ID, this.ID, messageType);
        switch(messageType) {
            case "requestConnection":
                this.confirmConnection(fromConnection);
                break;
            case "approvedConnection":
                this.approvedConnection(fromConnection);
                break;
            case "insertConnection":
                this.insertConnection(fromConnection);
                break;
            case "setPreviousConnection":
                this.setPreviousConnection(fromConnection);
                break;
            case "setNextConnection":
                this.setNextConnection(fromConnection);
                break;
        }
    }

    // Process each connection with a given function
    processConnections(processFn) {
        return this.connections.map(processFn);
    }
    
    // Process connections with async functions
    async processConnectionsAsync(processFn) {
        return Promise.all(this.connections.map(processFn));
    }

    // Update all instances of a connection across connections, previous, and next arrays
    updateConnection(newConnection) {
        let updated = false;
        
        // Update main connections array
        this.connections = this.connections.map(conn => {
            if (conn.ID === newConnection.ID) {
                updated = true;
                return newConnection;
            }
            return conn;
        });

        // Update previous array
        this.previous = this.previous.map(conn => {
            if (conn.ID === newConnection.ID) {
                updated = true;
                return newConnection.clone();
            }
            return conn;
        });

        // Update next array
        this.next = this.next.map(conn => {
            if (conn.ID === newConnection.ID) {
                updated = true;
                return newConnection.clone();
            }
            return conn;
        });

        return updated;
    }

    // Alternative version using processConnections
    updateConnectionAlt(newConnection) {
        const updateArray = (array) => {
            return array.map(conn => 
                conn.ID === newConnection.ID ? newConnection.clone() : conn
            );
        };

        // Update all arrays
        this.connections = updateArray(this.connections);
        this.previous = updateArray(this.previous);
        this.next = updateArray(this.next);

        // Check if any updates were made
        return [...this.connections, ...this.previous, ...this.next]
            .some(conn => conn.ID === newConnection.ID);
    }

    findConnection(nodeId) {
        // Determine search direction based on target nodeId
        const searchGreater = Node.getDistance(this.ID, nodeId) > 0;
        
        let bestConnection = null;
        let bestDistance = Infinity;

        // Helper function to check and update best connection
        const checkConnection = (connection) => {
            // Skip if connection is in wrong direction relative to this.ID
            const connectionDist = Node.getDistance(this.ID, connection.ID);
            if (searchGreater && connectionDist <= 0) return;
            if (!searchGreater && connectionDist >= 0) return;
            
            // Calculate distance to target nodeId
            const distance = Math.abs(Node.getDistance(connection.ID, nodeId));
            if (distance < bestDistance) {
                bestDistance = distance;
                bestConnection = connection;
            }
        };

        // Search this.connections using binary search since it's sorted
        let left = 0;
        let right = this.connections.length - 1;
        
        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            const connection = this.connections[mid];
            const midDist = Node.getDistance(this.ID, connection.ID);
            
            // Check if this connection is in the correct direction
            if ((searchGreater && midDist > 0) || (!searchGreater && midDist < 0)) {
                checkConnection(connection);
            }
            
            if (connection.ID < nodeId) {
                left = mid + 1;
            } else if (connection.ID > nodeId) {
                right = mid - 1;
            } else {
                // Exact match found
                checkConnection(connection);
                break;
            }
        }

        // Linear search through this.previous
        for (const connection of this.previous) {
            checkConnection(connection);
        }

        // Linear search through this.next
        for (const connection of this.next) {
            checkConnection(connection);
        }

        return bestConnection;
    }
}

//-----------------------------------------------------------------------
// Connection Class
// A connection holds information about a target node that allows another
// node to send messages to it.
//-----------------------------------------------------------------------
class Connection {
    constructor(toConnection) {
        this.address = toConnection.address;
        this.ID = toConnection.ID;
        this.secret = toConnection.secret;
        this.lastAccessed = new Date();
    }

    set secret(secret) { this._secret = secret; }
    get secret() { return this._secret; }

    get ID() { this.lastAccessed = new Date(); return this._ID; }
    set ID(id) { this.lastAccessed = new Date(); this._ID = id; }

    // Add clone method
    clone() {
        const cloned = new Connection(this);
        return cloned;
    }
}

//-----------------------------------------------------------------------
// Simulation
// Construct a structured node mesh
// The node ID/public key is a unique identifier for the node
// For simulation purposes, we will use Math.random() to generate a unique ID for each node
//-----------------------------------------------------------------------
// max live connections that a node can have
const MAX_CONNECTIONS = 10;

// all of the nodes in the global mesh
const nodeMesh = []; 

console.log("nodeMesh", nodeMesh);
// Get random node from the nodeMesh population
const getRandomNode = () => {
    const randomIndex = Math.floor(Math.random() * nodeMesh.length);
    return nodeMesh[randomIndex];
}

// Get a random ID from the node population
const getRandomID = () => {
    const node = getRandomNode();
    return node.ID;
}

new Node(); // create the first node

for(let i = 0; i < 100; i++) {  
    console.log("--------------------------Creating node", i);
    // create a new node and connect it to a random node in the mesh
    const node = new Node(getRandomNode());
    console.log(node.ID);
}